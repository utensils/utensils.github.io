<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png" data-next-head=""/><link rel="manifest" href="/favicon/site.webmanifest" data-next-head=""/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000" data-next-head=""/><link rel="shortcut icon" href="/favicon/favicon.ico" data-next-head=""/><meta name="msapplication-TileColor" content="#000000" data-next-head=""/><meta name="msapplication-config" content="/favicon/browserconfig.xml" data-next-head=""/><meta name="theme-color" content="#000" data-next-head=""/><link rel="alternate" type="application/rss+xml" href="/feed.xml" data-next-head=""/><meta name="description" content="Home of the premier product studio" data-next-head=""/><title data-next-head="">Staying Clean with Git Hygiene | Utensils.io</title><meta property="og:title" content="Staying Clean with Git Hygiene | Utensils.io" data-next-head=""/><meta property="og:description" content="Practical tips for better version control that your teammates will thank you for" data-next-head=""/><meta property="og:image" content="https://utensils.io/logo.png" data-next-head=""/><meta property="og:url" content="https://utensils.io/articles/staying-clean-with-git-hygiene" data-next-head=""/><meta property="og:type" content="article" data-next-head=""/><meta property="og:site_name" content="Utensils.io" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:title" content="Staying Clean with Git Hygiene | Utensils.io" data-next-head=""/><meta name="twitter:description" content="Practical tips for better version control that your teammates will thank you for" data-next-head=""/><meta name="twitter:image" content="https://utensils.io/logo.png" data-next-head=""/><link rel="preload" href="/_next/static/css/ee2fbefe6c76a6d1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ee2fbefe6c76a6d1.css" data-n-g=""/><link rel="preload" href="/_next/static/css/fd10aaedcf85d48c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fd10aaedcf85d48c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-ee17a4c43a44d3e2.js" defer=""></script><script src="/_next/static/chunks/main-99fa197f23f793be.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4fb6a1a458821650.js" defer=""></script><script src="/_next/static/chunks/695-4568df259c13997f.js" defer=""></script><script src="/_next/static/chunks/568-37e5a513d0fa129c.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5Bslug%5D-30ed8f7207bfd22f.js" defer=""></script><script src="/_next/static/Um1-lr3K4IXIJU3rT7vNx/_buildManifest.js" defer=""></script><script src="/_next/static/Um1-lr3K4IXIJU3rT7vNx/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><main><div class="container ml-0 mr-auto px-5 overflow-x-hidden"><section class="flex-col flex items-left mt-20"><div class="flex-row flex items-left text-left"><a class="flex title-font font-medium items-center md:justify-start justify-center mr-4" href="/"><img src="/logo.png" class="w-12 h-12 mb-2"/></a><a href="/articles" class="pt-1 text-3xl text-red-500 hover:text-red-600 font-black hover:underline mr-4">Articles</a><a href="https://github.com/utensils" target="_blank" class="pt-1 text-3xl text-red-500 hover:text-red-600 font-black hover:underline">GitHub</a></div><div class="flex-col flex items-left mt-10"><h1 class="text-8xl font-black tracking-tighter leading-tight md:pr-8">Utensils</h1><span class="lowercase text-4xl text-gray-400">Staying Clean with Git Hygiene</span></div></section><article><div class="max-w-2xl mx-right pl-6 pt-6"><div class="text-lg font-bold"><time dateTime="2025-04-11">April 11, 2025</time></div><div class="flex flex-inline pb-2 pt-4"><div class="flex items-center"><div class="text-2xl font-bold text-red-500 hover:text-red-600 pr-2"><a href="https://github.com/doomspork" target="_blank" rel="noopener noreferrer">Sean Callan</a></div></div></div></div><div class="max-w-2xl mx-right pl-6 prose"><span class="text-gray-400 text-bold text-xl">Practical tips for better version control that your teammates will thank you for</span><div class="markdown-styles_markdown__HwUWZ"><h1>Git Hygiene</h1>
<p>Good Git practices aren't just about keeping your repository tidy though that's certainly not a bad thing. Git hygiene is about respecting your teammates' time and making collaboration smoother. Whether you're a Git novice or have been using it for years, these practices will help you and your team work more effectively together.</p>
<h2>Descriptive Commit Messages</h2>
<p>It shouldn't be necessary to look through all the changes of a commit to understand the intention. A well-crafted commit message serves as documentation that explains both the what and why of your changes, without having to dive into the code.</p>
<p>Things to keep in mind:</p>
<ul>
<li>Keep subject lines concise (50 characters is ideal, never exceed 72)</li>
<li>Use imperative tense ("Add feature" not "Added feature")</li>
<li>Reference your project management ticket (GitHub, Jira, Linear, etc.)</li>
<li>Wrap commit bodies at 72 characters for better readability in terminals</li>
<li>Focus on WHY and WHAT, not HOW</li>
</ul>
<p>Rather than reinventing the wheel exploring adopting <a href="https://www.conventionalcommits.org/">Conventional Commits</a>. Conventional Commits is an easy to use convention that adds structure and consistency to your commit messages making it easy for you and others to quickly identify the intent. Another added benefit of Conventional Commit adoption is unlocking cool tooling like <a href="https://github.com/googleapis/release-please">Release-please</a> and <a href="https://github.com/semantic-release/semantic-release">Semantic-release</a>.</p>
<h3>Examples</h3>
<p><strong>Bad Commit</strong></p>
<pre class="language-bash"><code class="language-bash">Modified user authentication system by updating the authentication <span class="token function">service</span> class and adding a new middleware component that intercepts requests, checks <span class="token keyword">for</span> session tokens <span class="token keyword">in</span> cookies or headers, validates them against our database, and <span class="token keyword">then</span> either allows the request to <span class="token builtin class-name">continue</span> or redirects to login page, also updated the login form component to handle the new error messages that might be returned from the backend and fixed several CSS issues with the form on mobile devices

I spent several hours debugging why the token validation was failing and discovered that we needed to check <span class="token keyword">for</span> token expiration. I implemented this by adding a new utility <span class="token keyword">function</span> that handles JWT decoding and validation. Then I had to update the tests to mock the token validation. I also noticed the CSS was broken on mobile so I changed the media queries to fix that issue. The login form wasn't handling errors correctly so I added some error message handling to display validation errors to the user.</code></pre>
<p>What went wrong with this commit?</p>
<ul>
<li>The subject line is extremely long and not concise</li>
<li>It focuses on HOW the changes were made, not WHY</li>
<li>It combines multiple unrelated changes in one commit</li>
<li>It includes personal details about debugging time</li>
<li>It lacks structure and is difficult to scan</li>
</ul>
<p><strong>Good Commit</strong></p>
<pre class="language-bash"><code class="language-bash">fix<span class="token punctuation">(</span>auth<span class="token punctuation">)</span>: implement proper token validation and expiration checking

BREAKING CHANGE: Auth middleware now requires valid JWT tokens with expiration dates

Problem:
- User sessions remained active indefinitely
- Authentication tokens weren't properly validated
- Security vulnerability allowed bypassing authentication

Solution:
- Add token expiration validation
- Implement proper error handling <span class="token keyword">for</span> invalid tokens
- Return <span class="token function">clear</span> error messages to the frontend

Resolves: <span class="token comment">#423</span></code></pre>
<p>Strengths of this format:</p>
<ul>
<li>Uses conventional commit format with type and scope (<code>fix(auth)</code>)</li>
<li>Includes a concise subject line that explains WHAT was done</li>
<li>Marks breaking changes clearly (when applicable)</li>
<li>The body explains WHAT <em>and</em> WHY</li>
<li>References the related issue number</li>
<li>Succinct and focused on a single logical change</li>
</ul>
<h2>Atomic Commits</h2>
<p>Each commit should represent one logical change: fix a bug, add a feature, update documentation, etc. Each of our commits should be a single unit of work that can stand on its own.</p>
<p><strong>Benefits of atomic commits:</strong></p>
<ul>
<li><strong>Simpler debugging</strong> - When tracking down issues with <code>git bisect</code></li>
<li><strong>Clean reverts</strong> - Undo specific changes without affecting others</li>
<li><strong>Cherry-picking</strong> - Apply specific changes to other branches seamlessly with <code>git cherrypick</code></li>
</ul>
<p>For example, let's consider a feature that requires both API changes and UI updates:</p>
<pre class="language-bash"><code class="language-bash">feat<span class="token punctuation">(</span>api<span class="token punctuation">)</span>: <span class="token function">add</span> new endpoint <span class="token keyword">for</span> user preferences
feat<span class="token punctuation">(</span>ui<span class="token punctuation">)</span>: create settings page <span class="token keyword">for</span> user preferences</code></pre>
<h2>Avoid Committing Generated/Built Files</h2>
<p>Our source control should be focused on our code and not artifacts that can be regenerated. Use <code>.gitignore</code> to exclude:</p>
<ul>
<li>Build outputs (compiled code, minified assets)</li>
<li>Dependency directories (node_modules, vendor)</li>
<li>Local environment files (.env)</li>
<li>Log files and databases</li>
<li>IDE-specific files</li>
</ul>
<p>Keeping these files out of your repository helps:</p>
<ul>
<li>Reduce repository bloat</li>
<li>Prevent unnecessary merge conflicts</li>
<li>Maintain cleaner diffs</li>
</ul>
<p>GitHub provides excellent <a href="https://github.com/github/gitignore">starter templates</a> for language-specific <code>.gitignore</code> files or checkout <a href="https://gitignore.io/">gitignore.io</a>.</p>
<h2>Rebase Locally Before Pushing (When Appropriate)</h2>
<p>Using <code>git rebase</code> keeps your commit history clean and linear, making it easier to follow. It's particularly useful when:</p>
<ul>
<li>Incorporating upstream changes into your feature branch</li>
<li>Cleaning up work-in-progress commits before sharing</li>
<li>Resolving conflicts with the main branch before opening a PR</li>
</ul>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> checkout main
<span class="token function">git</span> pull

<span class="token function">git</span> checkout feature-branch
<span class="token function">git</span> rebase main</code></pre>
<p>Rebasing is an incredibly powerful feature of git worth getting familiar and comfortable with. Once you're comfortable explore interactive rebasing, fixup commits, autosquashing, and other capabilities of rebase to really level up your Git game.</p>
<h2>Squash Commits Before Merging</h2>
<p>When developing a feature, you'll often make multiple small, iterative commits:</p>
<pre><code>wip: start implementing login form
fix: handle input validation
fix: typo in error message
feat: complete login form with tests
</code></pre>
<p>These incremental steps are helpful during development but are noise in the project's history. Squashing commits before merging ensures a clean meaningful git history.</p>
<p>Most Git platforms offer a "Squash and merge" option for PRs, or you can do it manually:</p>
<pre class="language-bash"><code class="language-bash"><span class="token comment"># Squash the last 4 commits</span>
<span class="token function">git</span> rebase <span class="token parameter variable">-i</span> HEAD~4</code></pre>
<h2>Keep Branches Focused and Short-Lived</h2>
<p>Branches should represent a single unit of work:</p>
<ul>
<li>One feature, bugfix, or improvement</li>
<li>A reasonable scope that can be completed quickly</li>
<li>A clear connection to a project management ticket</li>
</ul>
<p>Long-lived branches tend to:</p>
<ul>
<li>Accumulate merge conflicts</li>
<li>Become difficult to review</li>
<li>Delay feedback on your work</li>
</ul>
<p>Try to keep branches alive for days, not weeks or months, and aim for regular integration with the main branch.</p>
<h2>Pull Request (PR) Etiquette</h2>
<p>Pull requests are a communication tool as much as a code review mechanism:</p>
<ul>
<li><strong>Keep them small</strong> - Aim for under 500 lines when possible</li>
<li><strong>Write clear descriptions</strong> - Explain the purpose, approach, and testing</li>
<li><strong>Use templates</strong> - Create PR templates to standardize information</li>
<li><strong>Request reviewers early</strong> - Get feedback before spending too much time</li>
<li><strong>Be responsive</strong> - Address comments promptly and thoughtfully</li>
<li><strong>Use draft PRs</strong> - Signal work in progress that's not ready for merge</li>
</ul>
<p>When writing your PR description some things to consider:</p>
<ul>
<li>What problem it solves</li>
<li>How it was tested</li>
<li>Any performance considerations</li>
<li>Screenshots for UI changes</li>
<li>Potential risks or trade-offs</li>
</ul>
<h2>Pre-commit Hooks</h2>
<p>We've all worked with someone who uses CI to test and lint their code, we've all probably complained about that person too. Do yourself a favor and catch issues before they enter your repository by automating checks at commit time. The <a href="https://pre-commit.com/">pre-commit framework</a> makes it easy to set up hooks for:</p>
<ul>
<li>Linting</li>
<li>Formatting</li>
<li>Running tests</li>
<li>Checking for secrets or credentials</li>
<li>Validating commit messages</li>
</ul>
<p>By catching these issues early, you can reduce feedback cycles and avoid burdening teammates with trivial fixes.</p>
<p>Don't rely solely on CI pipelines to catch issues that could be found locally. This creates unnecessary delays and additional work for your collaborators.</p>
<h2>Final Thoughts</h2>
<p>Good Git hygiene is about more than just keeping your repository clean, by adopting these practices you'll create a more collaborative, efficient development process where everyone can focus on building great software instead of fighting with version control.</p>
</div></div></article></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"authors":[{"name":"Sean Callan","github":"https://github.com/doomspork"}],"content":"\u003ch1\u003eGit Hygiene\u003c/h1\u003e\n\u003cp\u003eGood Git practices aren't just about keeping your repository tidy though that's certainly not a bad thing. Git hygiene is about respecting your teammates' time and making collaboration smoother. Whether you're a Git novice or have been using it for years, these practices will help you and your team work more effectively together.\u003c/p\u003e\n\u003ch2\u003eDescriptive Commit Messages\u003c/h2\u003e\n\u003cp\u003eIt shouldn't be necessary to look through all the changes of a commit to understand the intention. A well-crafted commit message serves as documentation that explains both the what and why of your changes, without having to dive into the code.\u003c/p\u003e\n\u003cp\u003eThings to keep in mind:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eKeep subject lines concise (50 characters is ideal, never exceed 72)\u003c/li\u003e\n\u003cli\u003eUse imperative tense (\"Add feature\" not \"Added feature\")\u003c/li\u003e\n\u003cli\u003eReference your project management ticket (GitHub, Jira, Linear, etc.)\u003c/li\u003e\n\u003cli\u003eWrap commit bodies at 72 characters for better readability in terminals\u003c/li\u003e\n\u003cli\u003eFocus on WHY and WHAT, not HOW\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRather than reinventing the wheel exploring adopting \u003ca href=\"https://www.conventionalcommits.org/\"\u003eConventional Commits\u003c/a\u003e. Conventional Commits is an easy to use convention that adds structure and consistency to your commit messages making it easy for you and others to quickly identify the intent. Another added benefit of Conventional Commit adoption is unlocking cool tooling like \u003ca href=\"https://github.com/googleapis/release-please\"\u003eRelease-please\u003c/a\u003e and \u003ca href=\"https://github.com/semantic-release/semantic-release\"\u003eSemantic-release\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eExamples\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eBad Commit\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003eModified user authentication system by updating the authentication \u003cspan class=\"token function\"\u003eservice\u003c/span\u003e class and adding a new middleware component that intercepts requests, checks \u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e session tokens \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e cookies or headers, validates them against our database, and \u003cspan class=\"token keyword\"\u003ethen\u003c/span\u003e either allows the request to \u003cspan class=\"token builtin class-name\"\u003econtinue\u003c/span\u003e or redirects to login page, also updated the login form component to handle the new error messages that might be returned from the backend and fixed several CSS issues with the form on mobile devices\n\nI spent several hours debugging why the token validation was failing and discovered that we needed to check \u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e token expiration. I implemented this by adding a new utility \u003cspan class=\"token keyword\"\u003efunction\u003c/span\u003e that handles JWT decoding and validation. Then I had to update the tests to mock the token validation. I also noticed the CSS was broken on mobile so I changed the media queries to fix that issue. The login form wasn't handling errors correctly so I added some error message handling to display validation errors to the user.\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat went wrong with this commit?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe subject line is extremely long and not concise\u003c/li\u003e\n\u003cli\u003eIt focuses on HOW the changes were made, not WHY\u003c/li\u003e\n\u003cli\u003eIt combines multiple unrelated changes in one commit\u003c/li\u003e\n\u003cli\u003eIt includes personal details about debugging time\u003c/li\u003e\n\u003cli\u003eIt lacks structure and is difficult to scan\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eGood Commit\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003efix\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eauth\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e: implement proper token validation and expiration checking\n\nBREAKING CHANGE: Auth middleware now requires valid JWT tokens with expiration dates\n\nProblem:\n- User sessions remained active indefinitely\n- Authentication tokens weren't properly validated\n- Security vulnerability allowed bypassing authentication\n\nSolution:\n- Add token expiration validation\n- Implement proper error handling \u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e invalid tokens\n- Return \u003cspan class=\"token function\"\u003eclear\u003c/span\u003e error messages to the frontend\n\nResolves: \u003cspan class=\"token comment\"\u003e#423\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStrengths of this format:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUses conventional commit format with type and scope (\u003ccode\u003efix(auth)\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eIncludes a concise subject line that explains WHAT was done\u003c/li\u003e\n\u003cli\u003eMarks breaking changes clearly (when applicable)\u003c/li\u003e\n\u003cli\u003eThe body explains WHAT \u003cem\u003eand\u003c/em\u003e WHY\u003c/li\u003e\n\u003cli\u003eReferences the related issue number\u003c/li\u003e\n\u003cli\u003eSuccinct and focused on a single logical change\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eAtomic Commits\u003c/h2\u003e\n\u003cp\u003eEach commit should represent one logical change: fix a bug, add a feature, update documentation, etc. Each of our commits should be a single unit of work that can stand on its own.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBenefits of atomic commits:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSimpler debugging\u003c/strong\u003e - When tracking down issues with \u003ccode\u003egit bisect\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eClean reverts\u003c/strong\u003e - Undo specific changes without affecting others\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCherry-picking\u003c/strong\u003e - Apply specific changes to other branches seamlessly with \u003ccode\u003egit cherrypick\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, let's consider a feature that requires both API changes and UI updates:\u003c/p\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003efeat\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eapi\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e: \u003cspan class=\"token function\"\u003eadd\u003c/span\u003e new endpoint \u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e user preferences\nfeat\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eui\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e: create settings page \u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e user preferences\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eAvoid Committing Generated/Built Files\u003c/h2\u003e\n\u003cp\u003eOur source control should be focused on our code and not artifacts that can be regenerated. Use \u003ccode\u003e.gitignore\u003c/code\u003e to exclude:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBuild outputs (compiled code, minified assets)\u003c/li\u003e\n\u003cli\u003eDependency directories (node_modules, vendor)\u003c/li\u003e\n\u003cli\u003eLocal environment files (.env)\u003c/li\u003e\n\u003cli\u003eLog files and databases\u003c/li\u003e\n\u003cli\u003eIDE-specific files\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eKeeping these files out of your repository helps:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReduce repository bloat\u003c/li\u003e\n\u003cli\u003ePrevent unnecessary merge conflicts\u003c/li\u003e\n\u003cli\u003eMaintain cleaner diffs\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGitHub provides excellent \u003ca href=\"https://github.com/github/gitignore\"\u003estarter templates\u003c/a\u003e for language-specific \u003ccode\u003e.gitignore\u003c/code\u003e files or checkout \u003ca href=\"https://gitignore.io/\"\u003egitignore.io\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eRebase Locally Before Pushing (When Appropriate)\u003c/h2\u003e\n\u003cp\u003eUsing \u003ccode\u003egit rebase\u003c/code\u003e keeps your commit history clean and linear, making it easier to follow. It's particularly useful when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIncorporating upstream changes into your feature branch\u003c/li\u003e\n\u003cli\u003eCleaning up work-in-progress commits before sharing\u003c/li\u003e\n\u003cli\u003eResolving conflicts with the main branch before opening a PR\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"token function\"\u003egit\u003c/span\u003e checkout main\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e pull\n\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e checkout feature-branch\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e rebase main\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRebasing is an incredibly powerful feature of git worth getting familiar and comfortable with. Once you're comfortable explore interactive rebasing, fixup commits, autosquashing, and other capabilities of rebase to really level up your Git game.\u003c/p\u003e\n\u003ch2\u003eSquash Commits Before Merging\u003c/h2\u003e\n\u003cp\u003eWhen developing a feature, you'll often make multiple small, iterative commits:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewip: start implementing login form\nfix: handle input validation\nfix: typo in error message\nfeat: complete login form with tests\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese incremental steps are helpful during development but are noise in the project's history. Squashing commits before merging ensures a clean meaningful git history.\u003c/p\u003e\n\u003cp\u003eMost Git platforms offer a \"Squash and merge\" option for PRs, or you can do it manually:\u003c/p\u003e\n\u003cpre class=\"language-bash\"\u003e\u003ccode class=\"language-bash\"\u003e\u003cspan class=\"token comment\"\u003e# Squash the last 4 commits\u003c/span\u003e\n\u003cspan class=\"token function\"\u003egit\u003c/span\u003e rebase \u003cspan class=\"token parameter variable\"\u003e-i\u003c/span\u003e HEAD~4\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eKeep Branches Focused and Short-Lived\u003c/h2\u003e\n\u003cp\u003eBranches should represent a single unit of work:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOne feature, bugfix, or improvement\u003c/li\u003e\n\u003cli\u003eA reasonable scope that can be completed quickly\u003c/li\u003e\n\u003cli\u003eA clear connection to a project management ticket\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLong-lived branches tend to:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAccumulate merge conflicts\u003c/li\u003e\n\u003cli\u003eBecome difficult to review\u003c/li\u003e\n\u003cli\u003eDelay feedback on your work\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTry to keep branches alive for days, not weeks or months, and aim for regular integration with the main branch.\u003c/p\u003e\n\u003ch2\u003ePull Request (PR) Etiquette\u003c/h2\u003e\n\u003cp\u003ePull requests are a communication tool as much as a code review mechanism:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eKeep them small\u003c/strong\u003e - Aim for under 500 lines when possible\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWrite clear descriptions\u003c/strong\u003e - Explain the purpose, approach, and testing\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse templates\u003c/strong\u003e - Create PR templates to standardize information\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRequest reviewers early\u003c/strong\u003e - Get feedback before spending too much time\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBe responsive\u003c/strong\u003e - Address comments promptly and thoughtfully\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse draft PRs\u003c/strong\u003e - Signal work in progress that's not ready for merge\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen writing your PR description some things to consider:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat problem it solves\u003c/li\u003e\n\u003cli\u003eHow it was tested\u003c/li\u003e\n\u003cli\u003eAny performance considerations\u003c/li\u003e\n\u003cli\u003eScreenshots for UI changes\u003c/li\u003e\n\u003cli\u003ePotential risks or trade-offs\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003ePre-commit Hooks\u003c/h2\u003e\n\u003cp\u003eWe've all worked with someone who uses CI to test and lint their code, we've all probably complained about that person too. Do yourself a favor and catch issues before they enter your repository by automating checks at commit time. The \u003ca href=\"https://pre-commit.com/\"\u003epre-commit framework\u003c/a\u003e makes it easy to set up hooks for:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinting\u003c/li\u003e\n\u003cli\u003eFormatting\u003c/li\u003e\n\u003cli\u003eRunning tests\u003c/li\u003e\n\u003cli\u003eChecking for secrets or credentials\u003c/li\u003e\n\u003cli\u003eValidating commit messages\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBy catching these issues early, you can reduce feedback cycles and avoid burdening teammates with trivial fixes.\u003c/p\u003e\n\u003cp\u003eDon't rely solely on CI pipelines to catch issues that could be found locally. This creates unnecessary delays and additional work for your collaborators.\u003c/p\u003e\n\u003ch2\u003eFinal Thoughts\u003c/h2\u003e\n\u003cp\u003eGood Git hygiene is about more than just keeping your repository clean, by adopting these practices you'll create a more collaborative, efficient development process where everyone can focus on building great software instead of fighting with version control.\u003c/p\u003e\n","date":"2025-04-11","excerpt":"Practical tips for better version control that your teammates will thank you for","slug":"staying-clean-with-git-hygiene","title":"Staying Clean with Git Hygiene"}},"__N_SSG":true},"page":"/articles/[slug]","query":{"slug":"staying-clean-with-git-hygiene"},"buildId":"Um1-lr3K4IXIJU3rT7vNx","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>