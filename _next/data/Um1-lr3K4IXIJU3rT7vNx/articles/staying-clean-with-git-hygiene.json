{"pageProps":{"article":{"authors":[{"name":"Sean Callan","github":"https://github.com/doomspork"}],"content":"<h1>Git Hygiene</h1>\n<p>Good Git practices aren't just about keeping your repository tidy though that's certainly not a bad thing. Git hygiene is about respecting your teammates' time and making collaboration smoother. Whether you're a Git novice or have been using it for years, these practices will help you and your team work more effectively together.</p>\n<h2>Descriptive Commit Messages</h2>\n<p>It shouldn't be necessary to look through all the changes of a commit to understand the intention. A well-crafted commit message serves as documentation that explains both the what and why of your changes, without having to dive into the code.</p>\n<p>Things to keep in mind:</p>\n<ul>\n<li>Keep subject lines concise (50 characters is ideal, never exceed 72)</li>\n<li>Use imperative tense (\"Add feature\" not \"Added feature\")</li>\n<li>Reference your project management ticket (GitHub, Jira, Linear, etc.)</li>\n<li>Wrap commit bodies at 72 characters for better readability in terminals</li>\n<li>Focus on WHY and WHAT, not HOW</li>\n</ul>\n<p>Rather than reinventing the wheel exploring adopting <a href=\"https://www.conventionalcommits.org/\">Conventional Commits</a>. Conventional Commits is an easy to use convention that adds structure and consistency to your commit messages making it easy for you and others to quickly identify the intent. Another added benefit of Conventional Commit adoption is unlocking cool tooling like <a href=\"https://github.com/googleapis/release-please\">Release-please</a> and <a href=\"https://github.com/semantic-release/semantic-release\">Semantic-release</a>.</p>\n<h3>Examples</h3>\n<p><strong>Bad Commit</strong></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">Modified user authentication system by updating the authentication <span class=\"token function\">service</span> class and adding a new middleware component that intercepts requests, checks <span class=\"token keyword\">for</span> session tokens <span class=\"token keyword\">in</span> cookies or headers, validates them against our database, and <span class=\"token keyword\">then</span> either allows the request to <span class=\"token builtin class-name\">continue</span> or redirects to login page, also updated the login form component to handle the new error messages that might be returned from the backend and fixed several CSS issues with the form on mobile devices\n\nI spent several hours debugging why the token validation was failing and discovered that we needed to check <span class=\"token keyword\">for</span> token expiration. I implemented this by adding a new utility <span class=\"token keyword\">function</span> that handles JWT decoding and validation. Then I had to update the tests to mock the token validation. I also noticed the CSS was broken on mobile so I changed the media queries to fix that issue. The login form wasn't handling errors correctly so I added some error message handling to display validation errors to the user.</code></pre>\n<p>What went wrong with this commit?</p>\n<ul>\n<li>The subject line is extremely long and not concise</li>\n<li>It focuses on HOW the changes were made, not WHY</li>\n<li>It combines multiple unrelated changes in one commit</li>\n<li>It includes personal details about debugging time</li>\n<li>It lacks structure and is difficult to scan</li>\n</ul>\n<p><strong>Good Commit</strong></p>\n<pre class=\"language-bash\"><code class=\"language-bash\">fix<span class=\"token punctuation\">(</span>auth<span class=\"token punctuation\">)</span>: implement proper token validation and expiration checking\n\nBREAKING CHANGE: Auth middleware now requires valid JWT tokens with expiration dates\n\nProblem:\n- User sessions remained active indefinitely\n- Authentication tokens weren't properly validated\n- Security vulnerability allowed bypassing authentication\n\nSolution:\n- Add token expiration validation\n- Implement proper error handling <span class=\"token keyword\">for</span> invalid tokens\n- Return <span class=\"token function\">clear</span> error messages to the frontend\n\nResolves: <span class=\"token comment\">#423</span></code></pre>\n<p>Strengths of this format:</p>\n<ul>\n<li>Uses conventional commit format with type and scope (<code>fix(auth)</code>)</li>\n<li>Includes a concise subject line that explains WHAT was done</li>\n<li>Marks breaking changes clearly (when applicable)</li>\n<li>The body explains WHAT <em>and</em> WHY</li>\n<li>References the related issue number</li>\n<li>Succinct and focused on a single logical change</li>\n</ul>\n<h2>Atomic Commits</h2>\n<p>Each commit should represent one logical change: fix a bug, add a feature, update documentation, etc. Each of our commits should be a single unit of work that can stand on its own.</p>\n<p><strong>Benefits of atomic commits:</strong></p>\n<ul>\n<li><strong>Simpler debugging</strong> - When tracking down issues with <code>git bisect</code></li>\n<li><strong>Clean reverts</strong> - Undo specific changes without affecting others</li>\n<li><strong>Cherry-picking</strong> - Apply specific changes to other branches seamlessly with <code>git cherrypick</code></li>\n</ul>\n<p>For example, let's consider a feature that requires both API changes and UI updates:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">feat<span class=\"token punctuation\">(</span>api<span class=\"token punctuation\">)</span>: <span class=\"token function\">add</span> new endpoint <span class=\"token keyword\">for</span> user preferences\nfeat<span class=\"token punctuation\">(</span>ui<span class=\"token punctuation\">)</span>: create settings page <span class=\"token keyword\">for</span> user preferences</code></pre>\n<h2>Avoid Committing Generated/Built Files</h2>\n<p>Our source control should be focused on our code and not artifacts that can be regenerated. Use <code>.gitignore</code> to exclude:</p>\n<ul>\n<li>Build outputs (compiled code, minified assets)</li>\n<li>Dependency directories (node_modules, vendor)</li>\n<li>Local environment files (.env)</li>\n<li>Log files and databases</li>\n<li>IDE-specific files</li>\n</ul>\n<p>Keeping these files out of your repository helps:</p>\n<ul>\n<li>Reduce repository bloat</li>\n<li>Prevent unnecessary merge conflicts</li>\n<li>Maintain cleaner diffs</li>\n</ul>\n<p>GitHub provides excellent <a href=\"https://github.com/github/gitignore\">starter templates</a> for language-specific <code>.gitignore</code> files or checkout <a href=\"https://gitignore.io/\">gitignore.io</a>.</p>\n<h2>Rebase Locally Before Pushing (When Appropriate)</h2>\n<p>Using <code>git rebase</code> keeps your commit history clean and linear, making it easier to follow. It's particularly useful when:</p>\n<ul>\n<li>Incorporating upstream changes into your feature branch</li>\n<li>Cleaning up work-in-progress commits before sharing</li>\n<li>Resolving conflicts with the main branch before opening a PR</li>\n</ul>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> checkout main\n<span class=\"token function\">git</span> pull\n\n<span class=\"token function\">git</span> checkout feature-branch\n<span class=\"token function\">git</span> rebase main</code></pre>\n<p>Rebasing is an incredibly powerful feature of git worth getting familiar and comfortable with. Once you're comfortable explore interactive rebasing, fixup commits, autosquashing, and other capabilities of rebase to really level up your Git game.</p>\n<h2>Squash Commits Before Merging</h2>\n<p>When developing a feature, you'll often make multiple small, iterative commits:</p>\n<pre><code>wip: start implementing login form\nfix: handle input validation\nfix: typo in error message\nfeat: complete login form with tests\n</code></pre>\n<p>These incremental steps are helpful during development but are noise in the project's history. Squashing commits before merging ensures a clean meaningful git history.</p>\n<p>Most Git platforms offer a \"Squash and merge\" option for PRs, or you can do it manually:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Squash the last 4 commits</span>\n<span class=\"token function\">git</span> rebase <span class=\"token parameter variable\">-i</span> HEAD~4</code></pre>\n<h2>Keep Branches Focused and Short-Lived</h2>\n<p>Branches should represent a single unit of work:</p>\n<ul>\n<li>One feature, bugfix, or improvement</li>\n<li>A reasonable scope that can be completed quickly</li>\n<li>A clear connection to a project management ticket</li>\n</ul>\n<p>Long-lived branches tend to:</p>\n<ul>\n<li>Accumulate merge conflicts</li>\n<li>Become difficult to review</li>\n<li>Delay feedback on your work</li>\n</ul>\n<p>Try to keep branches alive for days, not weeks or months, and aim for regular integration with the main branch.</p>\n<h2>Pull Request (PR) Etiquette</h2>\n<p>Pull requests are a communication tool as much as a code review mechanism:</p>\n<ul>\n<li><strong>Keep them small</strong> - Aim for under 500 lines when possible</li>\n<li><strong>Write clear descriptions</strong> - Explain the purpose, approach, and testing</li>\n<li><strong>Use templates</strong> - Create PR templates to standardize information</li>\n<li><strong>Request reviewers early</strong> - Get feedback before spending too much time</li>\n<li><strong>Be responsive</strong> - Address comments promptly and thoughtfully</li>\n<li><strong>Use draft PRs</strong> - Signal work in progress that's not ready for merge</li>\n</ul>\n<p>When writing your PR description some things to consider:</p>\n<ul>\n<li>What problem it solves</li>\n<li>How it was tested</li>\n<li>Any performance considerations</li>\n<li>Screenshots for UI changes</li>\n<li>Potential risks or trade-offs</li>\n</ul>\n<h2>Pre-commit Hooks</h2>\n<p>We've all worked with someone who uses CI to test and lint their code, we've all probably complained about that person too. Do yourself a favor and catch issues before they enter your repository by automating checks at commit time. The <a href=\"https://pre-commit.com/\">pre-commit framework</a> makes it easy to set up hooks for:</p>\n<ul>\n<li>Linting</li>\n<li>Formatting</li>\n<li>Running tests</li>\n<li>Checking for secrets or credentials</li>\n<li>Validating commit messages</li>\n</ul>\n<p>By catching these issues early, you can reduce feedback cycles and avoid burdening teammates with trivial fixes.</p>\n<p>Don't rely solely on CI pipelines to catch issues that could be found locally. This creates unnecessary delays and additional work for your collaborators.</p>\n<h2>Final Thoughts</h2>\n<p>Good Git hygiene is about more than just keeping your repository clean, by adopting these practices you'll create a more collaborative, efficient development process where everyone can focus on building great software instead of fighting with version control.</p>\n","date":"2025-04-11","excerpt":"Practical tips for better version control that your teammates will thank you for","slug":"staying-clean-with-git-hygiene","title":"Staying Clean with Git Hygiene"}},"__N_SSG":true}