{"pageProps":{"article":{"authors":[{"name":"James Brink","github":"https://github.com/jamesbrink"}],"content":"<h1>Forking Around: Copy-Pasta</h1>\n<h2>The ADHD Engineer's Guide to Massive Context Windows</h2>\n<p><em>By James Brink, \"SRE\" and Tinkerer of Terror</em></p>\n<p>Welcome to \"Forking Around\" - a new series where I'll be documenting my chaotic workflows and methodology as I stumble through the brave new world of AI. Consider this my public therapy session for dealing with the constant existential crisis of being an SRE in 2025. And yes, I'm fully aware this is the first post in what will inevitably become yet another abandoned project that I'll rediscover six months from now and think, \"Oh yeah, I was totally going to do that regularly.\" Let's all pretend I'll actually maintain this series for more than two posts.</p>\n<h2>When Your ADHD Brain Meets AI</h2>\n<p>I'll be honest - I rarely write Python these days because I'm project-hopping between Terraform, Ansible ü§Æ, NixOS, and all kinds of other shit that keeps my ADHD brain sufficiently distracted from dusk till dawn. So when I started working on my first <a href=\"https://github.com/utensils/mcp-nixos\">model context protocol server</a> recently, I was basically dusting off cobwebs in my brain while trying not to write code that would make junior devs point and laugh. Like any self-respecting engineer with commitment issues to any single technology stack, I immediately reached for AI assistance. Trust me, I am not concerned about being a great developer lol.</p>\n<p>But here's where I hit a wall that every engineer working with AI has encountered: context limitations. You know the drill - you're trying to review your growing codebase, but your AI agent is stuck in a perpetual state of amnesia, forgetting what it wrote where. It's like trying to explain your infrastructure to a new hire who keeps forgetting how SSH works.</p>\n<h2>Enter Gemini's Ridiculous Context Window</h2>\n<p>That's when I stumbled upon the totally obvious fact that Gemini's new 2.5 pro model can have a benefit to me.</p>\n<p>Why is this a game-changer for me? Because I can take my entire small/medium project and yeet that fucker ALL into a single prompt. No more fragmented reviews or AI amnesia (I hope). With the entire codebase visible at once, the LLM can actually see the mess I have been brewing locally.</p>\n<h3>My new workflow looks something like this:</h3>\n<ol>\n<li>Write mediocre code locally with my AI sidekick - let's not kid around, I might have written the README.md, and that's a lie too</li>\n<li>Realize things are getting unwieldy</li>\n<li>Export codebase to prompt format</li>\n<li>Dump into Gemini</li>\n<li>Get a comprehensive review that catches all the stupid stuff</li>\n<li>Fix said stupid stuff by passing it right back into the Agent that made the mess to begin with</li>\n<li>Repeat until code is marginally acceptable</li>\n</ol>\n<h2>The Tools That Make This Work</h2>\n<p>I've been using two tools to prep my code for these mega-reviews:</p>\n<ol>\n<li>\n<p><strong>RepoPrompt</strong> (<a href=\"https://repoprompt.com/\">https://repoprompt.com/</a>) - A GUI tool that's perfect for Mac users or those allergic to the command line. I liked it enough to grab a subscription, so shout out to that dev.</p>\n</li>\n<li>\n<p><strong>code2prompt</strong> (<a href=\"https://github.com/mufeedvh/code2prompt\">https://github.com/mufeedvh/code2prompt</a>) - Just discovered this one after RepoPrompt. Likely will be my go-to moving forward because I already have an ungodly amount of apps running constantly.</p>\n</li>\n</ol>\n<p>Both these tools can help you do the same thing, with Repo Prompt having far more features that I might never need: help you gather all your code into a format you can paste into Gemini's prompt. Your browser will hate you for it (seriously, it gets hella sluggish with larger codebases), but your future self will thank you.</p>\n<h2>Real Benefits I've Seen</h2>\n<p>In my first 48 hours of using this approach, I've already seen some serious wins:</p>\n<ol>\n<li>\n<p><strong>Quick refactoring validation</strong> - When I knew my flat directory structure wasn't going to last, Gemini confirmed my suspicions and suggested a better structure while ensuring package names, modules, and implementation details all remained consistent.</p>\n</li>\n<li>\n<p><strong>Catching architectural nonsense</strong> - With the entire codebase in context, Gemini can spot inconsistencies across files that might be missed when reviewing isolated chunks of code.</p>\n</li>\n<li>\n<p><strong>Time savings</strong> - Instead of manually poring through files to ensure my code isn't trash, I can get a detailed report on the entire codebase in minutes.</p>\n</li>\n</ol>\n<h2>Avoiding the AI Death Spiral</h2>\n<p>Now a word of caution for those of you diving into \"vibe coding\" (a term I refuse to embrace, despite my clear dependence on AI tools). There's a dangerous cycle that happens when you take your hands completely off the wheel:</p>\n<p>We all know this story: the AI implements something, realizes it doesn't work, unimplements it, implements it again slightly differently, with the exception of the AI agents that leverage memory and hilariously re-implement the exact bad solution. Looking at you Windsurf ‚ù§Ô∏è, all the while leaving a trail of unreachable code, broken tests, mock data where it shouldn't be and a mountain of absolutely stupid shell scripts nobody asked for when using Claude 3.7. Soon you've got a codebase that resembles the aftermath of a <a href=\"https://www.urbandictionary.com/define.php?term=Soup%20Kitchen\">Soup Kitchen</a>.</p>\n<p>This workflow isn't about replacing your brain - I will cover that in a future post - it's about augmenting it. Use the massive context window to get a 10,000-foot view of your code and create a solid feedback loop, then apply your own judgment to the recommendations.</p>\n<h2>The Misconception About AI and Coding</h2>\n<p>There's this persistent idea floating around that AI can only write bad code and isn't truly useful for \"real\" engineering work. I don't buy it. What I've found is that AI tools let me focus more on product or feature-based thinking while relaxing some of the low-level implementation details.</p>\n<p>Is it perfect? Hell no. It will still miss trivial shit that any junior dev would catch. But as another tool in the toolkit? It's proving to be invaluable - especially for someone like me who's constantly context-switching between projects and technologies thanks to my ADHD brain's inability to focus on any one thing for more than 37 seconds.</p>\n<h2>Current Limitations and Future Thoughts</h2>\n<p>This workflow is absolutely nothing groundbreaking, and is still new to me - as I have only been using it the last two days, but I'm already seeing a big fellow value that I wanted to share it with fellow tinkerers who might benefit.</p>\n<p>Some limitations to be aware of:</p>\n<ul>\n<li>The approach works best for small to medium-sized projects (my current context size is around 300,000 tokens)</li>\n<li>For larger projects, you'll need to be more selective about which parts you analyze together</li>\n<li>Gemini is currently free on the website (probably because it's experimental), but that might change... no clue because you know I am too lazy to go read their docs üòÇ</li>\n</ul>\n<hr>\n<p><em>If you've got your own AI workflows that have saved your dignity (or at least made your code marginally less embarrassing), drop me a line. My ADHD brain will probably forget it immediately, but it'll make for great content in future installments of \"Forking Around.\"</em></p>\n","date":"2025-03-30","excerpt":"How I leverage Gemini's massive context window to review entire codebases and save my ADHD brain from project chaos.","slug":"copy-pasta-the-adhd-engineers-guide-to-massive-context-windows","title":"Forking Around: Copy-Pasta - The ADHD Engineer's Guide to Massive Context Windows"}},"__N_SSG":true}